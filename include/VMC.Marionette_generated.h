// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VMCMARIONETTE_VMC_MARIONETTE_H_
#define FLATBUFFERS_GENERATED_VMCMARIONETTE_VMC_MARIONETTE_H_

#include "flatbuffers/flatbuffers.h"

namespace VMC {
namespace Marionette {

struct Available;

struct Vec3;

struct Vec4;

struct Command;
struct CommandBuilder;

struct Bone;
struct BoneBuilder;

struct Value;
struct ValueBuilder;

enum Address {
  Address_OK = 0,
  Address_VRM = 1,
  Address_Root_Pos = 2,
  Address_Bone_Pos = 3,
  Address_Blend_Val = 4,
  Address_Bend_Apply = 5,
  Address_MIN = Address_OK,
  Address_MAX = Address_Bend_Apply
};

inline const Address (&EnumValuesAddress())[6] {
  static const Address values[] = {
    Address_OK,
    Address_VRM,
    Address_Root_Pos,
    Address_Bone_Pos,
    Address_Blend_Val,
    Address_Bend_Apply
  };
  return values;
}

inline const char * const *EnumNamesAddress() {
  static const char * const names[7] = {
    "OK",
    "VRM",
    "Root_Pos",
    "Bone_Pos",
    "Blend_Val",
    "Bend_Apply",
    nullptr
  };
  return names;
}

inline const char *EnumNameAddress(Address e) {
  if (flatbuffers::IsOutRange(e, Address_OK, Address_Bend_Apply)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAddress()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Available FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t loaded_;
  int8_t calibrationState_;
  int8_t calibrationMode_;
  int8_t trackingState_;

 public:
  Available() {
    memset(static_cast<void *>(this), 0, sizeof(Available));
  }
  Available(int8_t _loaded, int8_t _calibrationState, int8_t _calibrationMode, int8_t _trackingState)
      : loaded_(flatbuffers::EndianScalar(_loaded)),
        calibrationState_(flatbuffers::EndianScalar(_calibrationState)),
        calibrationMode_(flatbuffers::EndianScalar(_calibrationMode)),
        trackingState_(flatbuffers::EndianScalar(_trackingState)) {
  }
  int8_t loaded() const {
    return flatbuffers::EndianScalar(loaded_);
  }
  int8_t calibrationState() const {
    return flatbuffers::EndianScalar(calibrationState_);
  }
  int8_t calibrationMode() const {
    return flatbuffers::EndianScalar(calibrationMode_);
  }
  int8_t trackingState() const {
    return flatbuffers::EndianScalar(trackingState_);
  }
};
FLATBUFFERS_STRUCT_END(Available, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() {
    memset(static_cast<void *>(this), 0, sizeof(Vec3));
  }
  Vec3(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec4 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4() {
    memset(static_cast<void *>(this), 0, sizeof(Vec4));
  }
  Vec4(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vec4, 16);

struct Command FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_LOCALTIME = 6,
    VT_AVAILABLE = 8,
    VT_BONES = 10,
    VT_VALUES = 12,
    VT_NAMES = 14
  };
  VMC::Marionette::Address address() const {
    return static_cast<VMC::Marionette::Address>(GetField<int8_t>(VT_ADDRESS, 0));
  }
  float localtime() const {
    return GetField<float>(VT_LOCALTIME, 0.0f);
  }
  const VMC::Marionette::Available *available() const {
    return GetStruct<const VMC::Marionette::Available *>(VT_AVAILABLE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<VMC::Marionette::Bone>> *bones() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VMC::Marionette::Bone>> *>(VT_BONES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<VMC::Marionette::Value>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VMC::Marionette::Value>> *>(VT_VALUES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ADDRESS) &&
           VerifyField<float>(verifier, VT_LOCALTIME) &&
           VerifyField<VMC::Marionette::Available>(verifier, VT_AVAILABLE) &&
           VerifyOffset(verifier, VT_BONES) &&
           verifier.VerifyVector(bones()) &&
           verifier.VerifyVectorOfTables(bones()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           VerifyOffset(verifier, VT_NAMES) &&
           verifier.VerifyVector(names()) &&
           verifier.VerifyVectorOfStrings(names()) &&
           verifier.EndTable();
  }
};

struct CommandBuilder {
  typedef Command Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(VMC::Marionette::Address address) {
    fbb_.AddElement<int8_t>(Command::VT_ADDRESS, static_cast<int8_t>(address), 0);
  }
  void add_localtime(float localtime) {
    fbb_.AddElement<float>(Command::VT_LOCALTIME, localtime, 0.0f);
  }
  void add_available(const VMC::Marionette::Available *available) {
    fbb_.AddStruct(Command::VT_AVAILABLE, available);
  }
  void add_bones(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VMC::Marionette::Bone>>> bones) {
    fbb_.AddOffset(Command::VT_BONES, bones);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VMC::Marionette::Value>>> values) {
    fbb_.AddOffset(Command::VT_VALUES, values);
  }
  void add_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names) {
    fbb_.AddOffset(Command::VT_NAMES, names);
  }
  explicit CommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CommandBuilder &operator=(const CommandBuilder &);
  flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline flatbuffers::Offset<Command> CreateCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    VMC::Marionette::Address address = VMC::Marionette::Address_OK,
    float localtime = 0.0f,
    const VMC::Marionette::Available *available = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VMC::Marionette::Bone>>> bones = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VMC::Marionette::Value>>> values = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> names = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_names(names);
  builder_.add_values(values);
  builder_.add_bones(bones);
  builder_.add_available(available);
  builder_.add_localtime(localtime);
  builder_.add_address(address);
  return builder_.Finish();
}

inline flatbuffers::Offset<Command> CreateCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    VMC::Marionette::Address address = VMC::Marionette::Address_OK,
    float localtime = 0.0f,
    const VMC::Marionette::Available *available = 0,
    const std::vector<flatbuffers::Offset<VMC::Marionette::Bone>> *bones = nullptr,
    const std::vector<flatbuffers::Offset<VMC::Marionette::Value>> *values = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *names = nullptr) {
  auto bones__ = bones ? _fbb.CreateVector<flatbuffers::Offset<VMC::Marionette::Bone>>(*bones) : 0;
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<VMC::Marionette::Value>>(*values) : 0;
  auto names__ = names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*names) : 0;
  return VMC::Marionette::CreateCommand(
      _fbb,
      address,
      localtime,
      available,
      bones__,
      values__,
      names__);
}

struct Bone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_I = 4,
    VT_P = 6,
    VT_Q = 8
  };
  int8_t i() const {
    return GetField<int8_t>(VT_I, 0);
  }
  const VMC::Marionette::Vec3 *p() const {
    return GetStruct<const VMC::Marionette::Vec3 *>(VT_P);
  }
  const VMC::Marionette::Vec4 *q() const {
    return GetStruct<const VMC::Marionette::Vec4 *>(VT_Q);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_I) &&
           VerifyField<VMC::Marionette::Vec3>(verifier, VT_P) &&
           VerifyField<VMC::Marionette::Vec4>(verifier, VT_Q) &&
           verifier.EndTable();
  }
};

struct BoneBuilder {
  typedef Bone Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_i(int8_t i) {
    fbb_.AddElement<int8_t>(Bone::VT_I, i, 0);
  }
  void add_p(const VMC::Marionette::Vec3 *p) {
    fbb_.AddStruct(Bone::VT_P, p);
  }
  void add_q(const VMC::Marionette::Vec4 *q) {
    fbb_.AddStruct(Bone::VT_Q, q);
  }
  explicit BoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoneBuilder &operator=(const BoneBuilder &);
  flatbuffers::Offset<Bone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bone>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bone> CreateBone(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t i = 0,
    const VMC::Marionette::Vec3 *p = 0,
    const VMC::Marionette::Vec4 *q = 0) {
  BoneBuilder builder_(_fbb);
  builder_.add_q(q);
  builder_.add_p(p);
  builder_.add_i(i);
  return builder_.Finish();
}

struct Value FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct ValueBuilder {
  typedef Value Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Value::VT_NAME, name);
  }
  void add_value(float value) {
    fbb_.AddElement<float>(Value::VT_VALUE, value, 0.0f);
  }
  explicit ValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ValueBuilder &operator=(const ValueBuilder &);
  flatbuffers::Offset<Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Value>(end);
    return o;
  }
};

inline flatbuffers::Offset<Value> CreateValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float value = 0.0f) {
  ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Value> CreateValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float value = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return VMC::Marionette::CreateValue(
      _fbb,
      name__,
      value);
}

inline const VMC::Marionette::Command *GetCommand(const void *buf) {
  return flatbuffers::GetRoot<VMC::Marionette::Command>(buf);
}

inline const VMC::Marionette::Command *GetSizePrefixedCommand(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<VMC::Marionette::Command>(buf);
}

inline bool VerifyCommandBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<VMC::Marionette::Command>(nullptr);
}

inline bool VerifySizePrefixedCommandBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<VMC::Marionette::Command>(nullptr);
}

inline void FinishCommandBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<VMC::Marionette::Command> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCommandBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<VMC::Marionette::Command> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Marionette
}  // namespace VMC

#endif  // FLATBUFFERS_GENERATED_VMCMARIONETTE_VMC_MARIONETTE_H_
